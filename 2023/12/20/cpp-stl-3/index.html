
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>C++ | STL III | Vanadium的小屋</title>
    <meta name="author" content="Vanadium" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://cdn.staticfile.org" />
<script src="https://cdn.staticfile.org/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.2/css/all.min.css" />
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.5.1/css/all.min.css" />
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.5.1/css/all.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://cdn.staticfile.org/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://cdn.staticfile.org/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.16.9/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 6.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>VANADIUM的小屋</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house"></i>
            <span>&ensp;主页</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card"></i>
            <span>&ensp;关于</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive"></i>
            <span>&ensp;归档</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-screwdriver-wrench"></i>
            <span>&ensp;工具</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags"></i>
            <span>&ensp;标签</span>
        </a>
        
        <a href="/songs">
            <i class="fa-brands fa-music"></i>
            <span>&ensp;音乐</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;VANADIUM的小屋</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">主页</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">关于</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">归档</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-screwdriver-wrench fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">工具</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">标签</div>
                    </div>
                </a>
                
                <a href="/songs">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-brands fa-music fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">音乐</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>
        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <!--card-->
<div id="home-card-in-post">    
    <div id="home-card">
    <div id="card-style" style="max-height: 75vh;">
    <div id="card-div">
        <div class="avatar">
            <img src="/images/avatar.jpg" alt="avatar" />
        </div>
        <div class="name" style="font-size:x-large;"><b>Vanadium</b></div>
        <div class="description">
            <p>ZJUer | Freshman | IS | 术力口 | 摸鱼 | OP</p>

        </div>
        
        

        <div class="friend-links">
            <div class="name"><b>Vanadium常用网址</b></div>
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://katex.org/docs/supported#math-operators">KateX手册</a>
            </div>
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://stackedit.io/app#">StackEdit</a>
            </div>
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://www.runoob.com/cssref/css-selectors.html">CSS手册</a>
            </div>            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://www.runoob.com/markdown/md-tutorial.html">Markdown手册</a>
            </div>            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://fontawesome.com/">Font Awesome 6</a>
            </div>            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://md.qikqiak.com/">Markdown-微信公众号</a>
            </div>            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="http://116.62.147.239:18080/">在线VSCode | 感恩洪神的无私分享</a>
            </div>
        </div>


        <!--music player
        <div class="friend-links">
            <iframe seamless="seamless" width="300px" id="card" src="//music.163.com/outchain/player?type=2&id=29751583&auto=1&height=66" frameborder="no"></iframe>
        </div>-->
    </div>
    
    
    
</div>



    </div>
</div>

<!--end-->

<div class="article">
    <div>
        <h1>C++ | STL III</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/12/20
        </span>
        
           
            <!--展示tags-->
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/C-C/" style="color: #00a596">C/C++</a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/OOP/" style="color: #03a9f4">OOP</a>
            </span>
            
        </span>
        


        
            <span class="category">
                <span class="icon"><i class="fa-solid fa-newspaper"></i></span>
                
                
                
                
                2023/12/21

                
            </span>
            


    </div>

    <!--<span class="date"><b>最后更新时间,请注意时效性!  </b><span>20231221</span></span>--> 

      
        <!--展示page的完整内容-->
    <div class="content" v-pre>
        <blockquote>
<p>在这一节, 我们将尝试探讨一个沟通了算法与容器的重要概念–迭代器</p>
</blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li><a target="_blank" rel="noopener" href="https://cplusplus.com/reference/">C艹STL库官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://xuan-insr.github.io/cpp/cpp_restart/8_stl/">咸鱼暄的代码空间 | 模板 (II) - 理解 STL：迭代器与函数对象</a></li>
<li><a target="_blank" rel="noopener" href="https://xuan-insr.github.io/cpp/%E7%90%86%E8%A7%A3%20STL%20-%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/">咸鱼暄的代码空间 | 理解 STL - 迭代器与函数对象</a></li>
</ul>
<span id="more"></span>

<p>&nbsp;</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="从指针到迭代器"><a href="#从指针到迭代器" class="headerlink" title="从指针到迭代器"></a>从指针到迭代器</h4><p><strong>迭代器iterator</strong>这个名词初见可能比较陌生, 因此在前一篇有关STL的文章 <a target="_blank" rel="noopener" href="https://z-vanadium.github.io/2023/12/17/cpp-stl/">C++ | STL I</a> 中, 我使用了指针来类比这个概念. 今天让我们继续从指针重新开始, 来理解迭代器.</p>
<p>数组是最简单的容器辣!</p>
<p>让我们考虑实现一个数组容器吧, 也不需要支持特别复杂的算法, 有最简单的增改删查就可以了, 因此我们直接考虑用C艹自带的数组来实现我们的数组, <strong>仿照STL的习惯</strong>, 我们把成员函数作如下命名</p>
<pre><code class="c++">template &lt;class ItemType, int Size&gt;
class my_array&#123;
    private:
        ItemType array[Size];
    public:
        my_array(ItemType initial, int num = Size); //将前num个元素赋初值initial
        void push_back(ItemType val);   //增加元素val
        ItemType* find(ItemType val);   //查找元素val
        ItemType&amp; at(ItemType* target); //用于修改target指向元素,返回数组元素的引用
        void erase(ItemType val);   //删除元素val,后面的元素前移
&#125;;
</code></pre>
<p>如果没有学习迭代器, 上面的写法已经是一个很优秀的回答了 <del>(因为是Vanadium写的)</del>, 我们主要关注查找函数的实现, 相信聪明的你很快就能做出实现</p>
<pre><code class="c++">template &lt;class ItemType, int Size&gt;
ItemType* my_array&lt;ItemType, Size&gt;::find(ItemType val)&#123;
    int iterator;
    for(iterator = 0;iterator &lt; Size;++iterator)&#123;
        if(*(array + iterator) == val)  break;
    &#125;
    return (array + iterator);  //未找到则返回末地址的下一位
&#125;
</code></pre>
<p>这个写法已经很完美了, 基本可以满足<strong>需求demand</strong>. 但是, 这是针对我们只有<code>my_array</code>这么一个需求的时候. 当我们需求扩大, 比如STL这样一个十分庞大的需求, 返回一个<code>ItemType*</code>是远不足以满足需求的. 比如我们需要一个<code>my_map</code>, 我们知道<code>map</code>在STL中是用<strong>红黑树red black tree</strong>实现的, 我们就要针对红黑树实现另外一个<code>find</code>函数–因为我们使用了指针的<code>++</code>运算和<code>*</code>解引用运算, 而这样的简单运算是不足以遍历红黑树的, 但是我们重新写一个这样的函数, 而不是选择重载, 就大大的违背了泛型编程的逻辑了. </p>
<p>最好的解决办法是保留这个弱爆了的遍历函数不动, 我们修改<code>ItemType*</code>为另外一个变量, 它能唯一的指向特定容器的某一个元素, 也能通过重载<code>++</code>运算和<code>*</code>解引用运算的方式实现对任一算法的适配, 定义这个新的变量类型, 用来代替指针的过程就被称为<strong>指针的抽象</strong>, 与此同时, 迭代器产生了.</p>
<p>假如我们已经拥有了迭代器类型<code>iterator</code>, 我们就可以改写那个<code>find</code>函数了.</p>
<pre><code class="c++">template &lt;class ItemType, int Size&gt;
my_array&lt;ItemType, Size&gt;::iterator my_array&lt;ItemType, Size&gt;::find(ItemType val)&#123;
    my_array&lt;ItemType, Size&gt;::iterator i;
    for(i = this-&gt;begin();i != this-&gt;end();++i)&#123;
        if(*i == val)  break;
    &#125;
    return i;   //未找到则返回末迭代器的后继
&#125;
//Tips: 行5的边界条件使用了`!=`而不是`&lt;`是因为不是所有迭代器都是可以比较大小的
</code></pre>
<p>在我们的写法中, 迭代器的定义更像是一个模板类中的类, 事实上也是如此, 以<code>my_array</code>为例, 我们会在类中定义一个类来实现迭代器(略去了影响观感的多余成员函数)</p>
<pre><code class="c++">template &lt;class ItemType, int Size&gt;
class my_array&#123;
    private:
        ItemType array[Size];
    public:
        class iterator;
        iterator begin()&#123;
            return iterator(this);
        &#125;
        iterator end()&#123;
            return iterator(this+Size);
        &#125;
        iterator find(ItemType val);   //查找元素val
&#125;;

template &lt;class ItemType, int Size&gt;
class my_array&lt;ItemType, Size&gt;::iterator&#123;
    private:
        ItemType* ptrItem;
    public:
        iterator(ItemType _ptrItem)&#123;
            ptrItem = _ptrItem;
        &#125;

        iterator&amp; operator++()&#123;
            ++ptrItem;
            return *this;
        &#125;

        bool operator!=(iterator tmp)&#123;
            return ptrItem != tmp.ptrItem;
        &#125;

        ItemType&amp; operator*()&#123;
            return (*ptrItem);
        &#125;
&#125;;
</code></pre>
<p>经过这样子的改写, 我们的<code>my_array</code>终于能支持迭代器了, 虽然对数组使用迭代器显得有些多余, 但我们的目标可是星辰大海! 况且, 我们目前已经跨出了第一步–从指针到迭代器</p>
<p>除此以外, 我们的<code>find</code>函数(算法)已经脱离了容器<code>my_array</code>, 这也从另一个侧面说明了STL的迭代器的作用, 沟通算法与容器, 避免算法错误的对不应被操作的容器操作, 以及方便算法的实现和重载</p>
<p>&nbsp;</p>
<p><strong>最后一个迭代器</strong></p>
<p>不论是数组还是抽象的遍历函数, 我们判断终点的方法都是<code>i != this-&gt;end()</code>, 这是由于我们想要程序在越过容器边界之后再进行退出. 之所这么做是有很多考量的, 其中之一就是方便程序的编写.</p>
<p>&nbsp;</p>
<h4 id="迭代器的分类"><a href="#迭代器的分类" class="headerlink" title="迭代器的分类"></a>迭代器的分类</h4><p>好的, 编写一个STL的小活动到此结束(当然我们也没有能力编写一个完整的STL, 毕竟一个<code>&lt;array&gt;</code>都有910行代码, 而<code>&lt;algorithm&gt;</code>包含了9948行代码!!!), 接下来我们继续往应用层面讨论迭代器的分类.</p>
<p>我们知道, 对于不同的容器, STL实现时, 采用了不同的数据结构, 同样的, 迭代器的实现也会使用不同的方法. 一个最简单的例子就是, 你无法对一个<code>set</code>容器使用<code>sort</code>函数, 但是<code>vector</code>却可以.</p>
<p>我们知道, STL的<code>sort</code>函数主要使用的是快速排序算法 <strong>(不知道就去看文档!)</strong>, 实现快速排序算法的必要条件就是能够以O(1)的代价随机访问元素, 并且能以O(1)的代价计算任意两个元素之间的距离; 用迭代器的语气说, 就是你要对迭代器与整型之间的<code>+=</code>, <code>-=</code>, <code>+</code>, <code>-</code>运算符和迭代器之间的<code>-</code>运算符有定义.</p>
<p>然而, 由于<code>set</code>的底层是红黑树, 我们并没有办法通过迭代器随机访问, 也没有办法计算距离, 因此<code>sort</code>无法对<code>set</code>使用; 对于<code>vector</code>, 我们知道它的实现其实是数组, 其迭代器的实现是指针, 而且拥有一块连续的内存, 因而可以满足要求.</p>
<p>让我们拿回上一篇有关STL的文章 <a target="_blank" rel="noopener" href="https://z-vanadium.github.io/2023/12/17/cpp-stl-2/">C++ | STL II</a> 的图</p>
<img src="https://github.com/Z-Vanadium/Z-Vanadium.github.io/blob/main/ImageHost/Illustrations/0020.png?raw=true">

<p>图源: <a target="_blank" rel="noopener" href="https://github.com/CppCon/CppCon2021/blob/main/Presentations/back_to_basics_classic_stl__bob_steagall__cppcon_2021_1.pdf">Github | PPT | Back to Basics: Classic STL - Bob Steagall - CppCon 2021</a></p>
<p>先不看表格的前面两行与输入输出有关的特化迭代器, 我们关注后面四个常见的迭代器, 我们从上往下看, 因为下面的迭代器是上面迭代器的加强版本.</p>
<p><strong>前向迭代器forward iterator</strong></p>
<p>前向迭代器支持多趟的对容器遍历, 并且在读写后依然指向同一个元素.</p>
<p>支持的操作: <code>* -&gt; ++ == != =</code></p>
<p>应用于: forward_list(单向链表), unordered_*(hash维护的单链表)</p>
<p><strong>双向迭代器bidirectional iterator</strong></p>
<p>在前者的基础上, 可以双向移动</p>
<p>额外支持的操作: <code>--</code></p>
<p>应用于: list(双向链表), set, map, multi*(红黑树)</p>
<p><strong>随机访问迭代器random access iterator</strong></p>
<p>在前者的基础上, 可以以O(1)的代价访问任一元素    </p>
<p>额外支持的操作: <code>[] += -= + - &lt; &gt; &lt;= &gt;=</code></p>
<p>应用于: deque(多个定长数组)</p>
<p><strong>连续迭代器contiguous iterator</strong></p>
<p>(C艹17+)在前者的基础上, 逻辑相邻的元素, 物理也相邻</p>
<p>额外支持的操作: 无</p>
<p>应用于: array, vector(数组)</p>
<p>&nbsp;</p>
<p><strong>一个容器的迭代器的种类决定了他能应用的算法.</strong> 因此, 我们不必机械的记忆适用于某一个或某一类的算法有哪些, 我们只需要思考算法的实现过程, 判断算法需求的迭代器的种类, 即可以更加普遍的方式获知算法的适用的容器. 当然, 比这种方法更加便捷的应当是查询文档–当且仅当无法确认时.  </p>
<p>&nbsp;</p>
<h4 id="比较器专栏"><a href="#比较器专栏" class="headerlink" title="比较器专栏"></a>比较器专栏</h4><p>在STL | III的最后, 我们来探讨一下比较器数的原理和用法. 在前一篇有关STL的文章 <a target="_blank" rel="noopener" href="https://z-vanadium.github.io/2023/12/17/cpp-stl/">C++ | STL I</a> 中, 我在最后提了一嘴降序序列如何设置<code>cmp</code>函数, 然而当时我们并没有系统的理解迭代器, 因此编写的<code>cmp</code>函数并不是一个良好的函数.</p>
<p><strong>匿名函数</strong></p>
<p>在C艹11+中, 提供了匿名函数(也被称为lambda表达式)以解决我们在使用STL的过程中, 定义了过多仅仅使用了一两次的函数类, 导致编译变慢或代码冗长臃肿的情况. 由于匿名函数可以在使用阈内部定义使用, 我们也将其称作匿名的内联函数.</p>
<p>匿名函数的语法格式如下:</p>
<pre><code class="c++">[capture](parameters) -&gt; return TypeName&#123;&#125;
</code></pre>
<p>在上面的定义中,</p>
<ul>
<li><code>[capture]</code>被称为捕获列表, 用于捕获外部变量</li>
<li><code>(parameters)</code>被称为参数列表, 相当于普通函数的参数列表, 采用形参传值的方法</li>
<li><code>-&gt; return TypeName</code>规定了匿名函数的返回值类型, 一般情况下可缺省, 交由编译器推导</li>
<li><code>&#123;&#125;</code>为函数体, 不要求只能包含一条语句, 也可以是语句块(但是语句过多, 就不适合使用匿名函数了)</li>
</ul>
<p>我们直接通过例子来理解匿名函数, 至于更细节的东西, 我们可以放到之后有机会再讲.</p>
<pre><code class="c++">#include&lt;iostream&gt;
using namespace std;

int main()&#123;
    auto my_max = [](int x, int y)&#123; return x&gt;y? x:y; &#125;;
    cout&lt;&lt;max(3,5)&lt;&lt;endl;
&#125;   
</code></pre>
<p>同样的, 我们也可以在当时的代码中, 使用匿名函数.   </p>
<pre><code class="c++">//原始代码
bool cmp(int x, int y)&#123;
    return !(x&lt;y);
&#125;
int main()&#123;
    int _array[] = &#123;1,4,6,2,4,5&#125;;
    vector&lt;int&gt; array(_array, _array+6);
    sort(array.begin(), array.end(), cmp);
    for(auto i=array.begin();i&lt;array.end();++i)&#123;
        cout&lt;&lt;*i&lt;&lt;&#39; &#39;;
    &#125;
    cout&lt;&lt;endl;
&#125;

//使用匿名函数
int main()&#123;
    int _array[] = &#123;1,4,6,2,4,5&#125;;
    vector&lt;int&gt; array(_array, _array+6);
    sort(array.begin(), array.end(), [](int x, int y)&#123; return !(x&lt;y); &#125;);
    for(auto i=array.begin();i&lt;array.end();++i)&#123;
        cout&lt;&lt;*i&lt;&lt;&#39; &#39;;
    &#125;
    cout&lt;&lt;endl;
&#125;
</code></pre>
<p>可以看到, 假如我们使用生命周期更短的匿名函数, 就可以减少对<code>cmp</code>函数的重载(因为我们不一定只需要一个特殊的cmp函数), 而是可以完全交由匿名函数完成.</p>
<p>&nbsp;</p>
<p><strong>比较器的本质</strong></p>
<p>让我们回到比较器, 回到使用比较器的典型函数<code>sort</code>, 参阅官方标准文档, 我们发现, <code>sort</code>只有两个函数签名</p>
<img src="https://raw.githubusercontent.com/Z-Vanadium/Z-Vanadium.github.io/main/ImageHost/Illustrations/0021.png">

<p>一个是缺省了比较器的版本(这个时候会调用重载后的<code>&lt;</code>运算符完成比较); 另一个就是带有比较器的版本, 但是奇怪的是, 我们可以使用很多种方式为<code>sort</code>传递比较器, 比如下列方法都是可以接受的</p>
<pre><code class="c++">// sort algorithm example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::sort
#include &lt;vector&gt;       // std::vector

bool myfunction (int i,int j) &#123; return (i&lt;j); &#125;

struct myclass &#123;
  bool operator() (int i,int j) &#123; return (i&lt;j);&#125;
&#125; myobject;

int main () &#123;
  int myints[] = &#123;32,71,12,45,26,80,53,33&#125;;
  std::vector&lt;int&gt; myvector (myints, myints+8);               // 32 71 12 45 26 80 53 33

  // using default comparison (operator &lt;):
  std::sort (myvector.begin(), myvector.begin()+4);           //(12 32 45 71)26 80 53 33

  // using function as comp
  std::sort (myvector.begin()+4, myvector.end(), myfunction); // 12 32 45 71(26 33 53 80)

  // using object as comp
  std::sort (myvector.begin(), myvector.end(), myobject);     //(12 26 32 33 45 53 71 80)

  // using lambda as comp
  std::sort (myvector.begin(), myvector.end(), [](int x, int y)&#123; return !(x&lt;y); &#125;) 

  // print out content:
  std::cout &lt;&lt; &quot;myvector contains:&quot;;
  for (std::vector&lt;int&gt;::iterator it=myvector.begin(); it!=myvector.end(); ++it)
    std::cout &lt;&lt; &#39; &#39; &lt;&lt; *it;
  std::cout &lt;&lt; &#39;\n&#39;;

  return 0;
&#125;
</code></pre>
<p>然而, 这么多种方法对应的仅有一个重载, 这说明, <strong>这么多实现方法的比较器的类型, 应该是一样的</strong>.</p>
<p>事实上, 这个相同的类型, 就是<strong>函数对象function object</strong>, 要注意的是, 函数对象中的对象, 与我们OOP中熟知的对象并不相同, 与此同时, 也要清楚<strong>函数并不是对象</strong>–包括结构体, 以及他们的模板和实例化, 他们统统都是一段代码而已. </p>
<p>具体来说, 函数对象指的, 就是函数指针, 可以转化为函数指针或是重载了<code>()</code>运算符的东西. 因此我们回头看上面的代码, 就可以理解他们分别调用了什么函数对象了</p>
<ul>
<li>行20: 函数指针</li>
<li>行23: 重载后的<code>()</code>运算符</li>
<li>行26: 可以转化为函数指针</li>
</ul>

    </div>




    

<!--friendlinks-->




<!--end-->

    
    
    
    
    
    


</div>

<!--
<div id="card-style">
<div id="card-div">
    <div class="avatar">
        <img src="/images/avatar.jpg" alt="avatar" />
    </div>
    <div class="name">Vanadium</div>
    <div class="description">
        <p>ZJUer | Freshman | IS | 术力口 | 摸鱼 | OP</p>

    </div>
    
    

    <div class="friend-links">
        <div class="name">Vanadium常用网址</div>
        <div class="friend-link">
            <a target="_blank" rel="noopener" href="https://katex.org/docs/supported#math-operators">KateX手册</a>
        </div>
        <div class="friend-link">
            <a target="_blank" rel="noopener" href="https://www.runoob.com/cssref/css-selectors.html">CSS手册</a>
        </div>            
        <div class="friend-link">
            <a target="_blank" rel="noopener" href="https://www.runoob.com/markdown/md-tutorial.html">Markdown手册</a>
        </div>
    </div>
</div>
</div>
-->
            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2023 Vanadium的小屋
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Vanadium
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>


    <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
    <script>
        var now = new Date(); 
        function createtime() { 
            var grt= new Date("09/26/2023 17:38:00");//在此处修改你的建站时间，格式：月/日/年 时:分:秒
            now.setTime(now.getTime()+250); 
            days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
            hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
            if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
            mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
            seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
            snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
            document.getElementById("timeDate").innerHTML = "本站已经存活 "+dnum+" 天 "; 
            document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
        } 
    setInterval("createtime()",250);
    </script>

</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    


    <!-- 一言API -->
    <!-- 现代写法，推荐 -->
    <script>
        fetch('https://v1.hitokoto.cn')
            .then(function (res){
            return res.json();
            })
            .then(function (data) {
            var hitokoto = document.getElementById('hitokoto');
            hitokoto.innerText = data.hitokoto + '——【' + data.from + '】';
            })
            .catch(function (err) {
            console.error(err);
            })
        </script>

</body>
</html>
