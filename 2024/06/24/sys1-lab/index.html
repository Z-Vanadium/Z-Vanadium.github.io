<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Computer System I Lab project 实验报告 | Vanadium的小屋</title><meta name="author" content="Vanadium"><meta name="copyright" content="Vanadium"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="写在前面 不知道什么原因, 也可能是因为博主能力有限, 很少找到 ZJU 计算机系统课的资料笔记, 而且由于该课程的 TA 生产力过高 (赞美 TA), 实验部分常常是一年一换, 因此想找到适合学习的资料更为难上加难 比如去年的实验内容应该是以 RV32I 为板子写 CPU, 今年就变成了 RV64I, 同时很多细节都不一样 (怒) 再此留下一份单周期 CPU 的实验报告, 鉴于一些别的原因, 源">
<meta property="og:type" content="article">
<meta property="og:title" content="Computer System I Lab project 实验报告">
<meta property="og:url" content="http://z-vanadium.github.io/2024/06/24/sys1-lab/index.html">
<meta property="og:site_name" content="Vanadium的小屋">
<meta property="og:description" content="写在前面 不知道什么原因, 也可能是因为博主能力有限, 很少找到 ZJU 计算机系统课的资料笔记, 而且由于该课程的 TA 生产力过高 (赞美 TA), 实验部分常常是一年一换, 因此想找到适合学习的资料更为难上加难 比如去年的实验内容应该是以 RV32I 为板子写 CPU, 今年就变成了 RV64I, 同时很多细节都不一样 (怒) 再此留下一份单周期 CPU 的实验报告, 鉴于一些别的原因, 源">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.imageoss.com/images/2024/03/28/f619d119ea8babb02498e3a91bdf9688ce395db803fc4641891cfa98.jpg">
<meta property="article:published_time" content="2024-06-24T13:01:50.046Z">
<meta property="article:modified_time" content="2024-06-28T10:32:05.587Z">
<meta property="article:author" content="Vanadium">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.imageoss.com/images/2024/03/28/f619d119ea8babb02498e3a91bdf9688ce395db803fc4641891cfa98.jpg"><link rel="shortcut icon" href="https://www.imageoss.com/images/2024/03/27/avatar84f10990023d148a.jpg"><link rel="canonical" href="http://z-vanadium.github.io/2024/06/24/sys1-lab/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Computer System I Lab project 实验报告',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-28 18:32:05'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://www.imageoss.com/images/2024/03/27/avatar84f10990023d148a.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-gamepad"></i><span> Games</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/finddiffcolor/"><i class="fa-fw fas fa-puzzle-piece"></i><span> FindDiffColor</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-share-nodes"></i><span> Share</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/chishenme/"><i class="fa-fw fas fa-utensils"></i><span> What2Eat</span></a></li><li><a class="site-page child" href="/songs/"><i class="fa-fw fas fa-music"></i><span> Songs</span></a></li><li><a class="site-page child" href="/reg_exp_visualize/"><i class="fa-fw fas fa-folder-open"></i><span> RegExpVisual</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-newspaper"></i><span> Posts</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/note-index/"><i class="fa-fw fas fa-note-sticky"></i><span> Notes</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://www.imageoss.com/images/2024/03/28/f619d119ea8babb02498e3a91bdf9688ce395db803fc4641891cfa98.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Vanadium的小屋"><span class="site-name">Vanadium的小屋</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-gamepad"></i><span> Games</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/finddiffcolor/"><i class="fa-fw fas fa-puzzle-piece"></i><span> FindDiffColor</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-share-nodes"></i><span> Share</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/chishenme/"><i class="fa-fw fas fa-utensils"></i><span> What2Eat</span></a></li><li><a class="site-page child" href="/songs/"><i class="fa-fw fas fa-music"></i><span> Songs</span></a></li><li><a class="site-page child" href="/reg_exp_visualize/"><i class="fa-fw fas fa-folder-open"></i><span> RegExpVisual</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-newspaper"></i><span> Posts</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/note-index/"><i class="fa-fw fas fa-note-sticky"></i><span> Notes</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Computer System I Lab project 实验报告</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-24T13:01:50.046Z" title="发表于 2024-06-24 21:01:50">2024-06-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-28T10:32:05.587Z" title="更新于 2024-06-28 18:32:05">2024-06-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">3.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>16分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Computer System I Lab project 实验报告"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="写在前面">写在前面</h3>
<p>不知道什么原因, 也可能是因为博主能力有限, 很少找到 ZJU 计算机系统课的资料笔记, 而且由于该课程的 TA 生产力过高 (赞美 TA), 实验部分常常是一年一换, 因此想找到适合学习的资料更为难上加难</p>
<p>比如去年的实验内容应该是以 RV32I 为板子写 CPU, 今年就变成了 RV64I, 同时很多细节都不一样 (怒)</p>
<p>再此留下一份单周期 CPU 的实验报告, 鉴于一些别的原因, 源码暂不开源, 权当抛砖引玉</p>
<hr>
<h3 id="数据通路设计">数据通路设计</h3>
<p>根据设计要求, 数据通路图如下</p>
<p><a target="_blank" rel="noopener" href="https://www.imageoss.com/image/vyp18D"><img src="https://www.imageoss.com/images/2024/06/28/datapath256774a14723cab2.jpg" alt="datapath256774a14723cab2.jpg"></a></p>
<p>由于我们设计的是单周期 CPU, 除内存模块, 寄存器模块 Reg[] 和 PC 外, 均可按照<strong>组合电路</strong>的设计模式设计</p>
<h4 id="Memory">Memory</h4>
<p>根据数据通路图, 数据走线不可避免地要与内存交流, 因此首先要分析 Memory 接口的结构</p>
<p>由于设计的是单周期 CPU, 所有的操作<strong>一定可以在一个时钟周期内</strong>完成, 不需要考虑很多, 只需要保持和 Memory 的数据信道的常开即可</p>
<p>需要考虑的是发送 / 接受的读写数据包格式 RrequestBit, RreplyBit, WrequestBit, WreplyBit; 这些格式在之后 <a target="_blank" rel="noopener" href="http://core.sv">core.sv</a> 文件编写的时候需要考虑</p>
<h4 id="RegFile">RegFile</h4>
<p>在 RISCV 架构中, 寄存器组一共有 32 个寄存器(x0 - x31), 其中 x0 始终是 0</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">if</span>(rst) <span class="keyword">begin</span>   <span class="comment">// 重置信号</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; <span class="number">32</span>; i++) <span class="keyword">begin</span></span><br><span class="line">      register[i] &lt;= <span class="number">0</span>;   <span class="comment">// 所有寄存器置 0</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(we) <span class="keyword">begin</span>  <span class="comment">// 如果处于写使能状态</span></span><br><span class="line">      <span class="keyword">if</span>(write_addr != <span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">        register[write_addr] &lt;= write_data;</span><br><span class="line">        <span class="comment">// 对非 x0 的寄存器写入</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> read_data_1 = register[read_addr_1];</span><br><span class="line"><span class="keyword">assign</span> read_data_2 = register[read_addr_2];</span><br><span class="line"><span class="comment">// 读取寄存器内容</span></span><br></pre></td></tr></table></figure>
<h4 id="ALU">ALU</h4>
<p>ALU(算术逻辑单元) 是执行算术计算的模块, 根据 RISCV 架构, ALU 需要支持以下操作</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] &#123;</span><br><span class="line">    ALU_ADD,  ALU_SUB,  ALU_AND,  ALU_OR,</span><br><span class="line">    ALU_XOR,  ALU_SLT,  ALU_SLTU, ALU_SLL,</span><br><span class="line">    ALU_SRL,  ALU_SRA,  ALU_ADDW, ALU_SUBW,</span><br><span class="line">    ALU_SLLW, ALU_SRLW, ALU_SRAW, ALU_DEFAULT</span><br><span class="line">&#125; alu_op_enum;</span><br></pre></td></tr></table></figure>
<p>根据各操作符的特点编写 <a target="_blank" rel="noopener" href="http://ALU.sv">ALU.sv</a></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span> (alu_op)</span><br><span class="line">        ALU_ADD: res = a + b;</span><br><span class="line">        ALU_SUB: res = a - b;</span><br><span class="line">        ALU_AND: res = a &amp; b;</span><br><span class="line">        ALU_OR: res = a | b;</span><br><span class="line">        ALU_XOR: res = a ^ b;</span><br><span class="line">        ALU_SLT: res = <span class="built_in">$signed</span>(a) &lt; <span class="built_in">$signed</span>(b) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        ALU_SLTU: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (a &lt; b) res = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        ALU_SLL: res = (a &lt;&lt; b[<span class="number">5</span>: <span class="number">0</span>]);</span><br><span class="line">        ALU_SRL: res = (a &gt;&gt; b[<span class="number">5</span>: <span class="number">0</span>]);</span><br><span class="line">        ALU_SRA: res = (<span class="built_in">$signed</span>(a) &gt;&gt;&gt; b[<span class="number">5</span>: <span class="number">0</span>]);</span><br><span class="line">        ALU_ADDW: res = &#123;&#123;<span class="number">32</span>&#123;a[<span class="number">31</span>]&#125;&#125;, a[<span class="number">31</span>:<span class="number">0</span>] + b[<span class="number">31</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">        ALU_SUBW: res = &#123;&#123;<span class="number">32</span>&#123;a[<span class="number">31</span>]&#125;&#125;, a[<span class="number">31</span>:<span class="number">0</span>] - b[<span class="number">31</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">        ALU_SLLW: res = &#123;&#123;<span class="number">32</span>&#123;a[<span class="number">31</span>]&#125;&#125;, a[<span class="number">31</span>:<span class="number">0</span>] &lt;&lt; b[<span class="number">4</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">        ALU_SRLW: res = &#123;&#123;<span class="number">32</span>&#123;a[<span class="number">31</span>]&#125;&#125;, a[<span class="number">31</span>:<span class="number">0</span>] &gt;&gt; b[<span class="number">4</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">        ALU_SRAW: res = &#123;&#123;<span class="number">32</span>&#123;a[<span class="number">31</span>]&#125;&#125;, <span class="built_in">$signed</span>(a[<span class="number">31</span>:<span class="number">0</span>]) &gt;&gt;&gt; b[<span class="number">4</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">        ALU_DEFAULT: res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="ALU-asel-和-ALU-bsel">ALU_asel 和 ALU_bsel</h4>
<p>ALU_asel 和 ALU_bsel 分别是 ALU 两个操作数的选择器</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] &#123;</span><br><span class="line">    ASEL0,  ASEL_REG,  ASEL_PC,  ASEL3</span><br><span class="line">&#125; alu_asel_op_enum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] &#123;</span><br><span class="line">    BSEL0,  BSEL_REG,  BSEL_IMM,  BSEL3</span><br><span class="line">&#125; alu_bsel_op_enum;</span><br></pre></td></tr></table></figure>
<p>ALU_asel 的选择范围是寄存器, PC; 而 ALU_bsel 的选择范围是寄存器, 立即数</p>
<p>再根据数据通路图中, 两者的端口情况编写 ALU_asel 和 ALU_bsel</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;core_struct.vh&quot;</span></span><br><span class="line"><span class="keyword">module</span> ALU_Asel (</span><br><span class="line">    <span class="keyword">input</span> CorePack::data_t a,</span><br><span class="line">    <span class="keyword">input</span> CorePack::alu_asel_op_enum alu_asel_op,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">63</span>: <span class="number">0</span>] pc,</span><br><span class="line">    <span class="keyword">output</span> CorePack::data_t alu_a</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">import</span> CorePack::*;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> (alu_asel_op)</span><br><span class="line">            ASEL0: alu_a = <span class="number">0</span>;</span><br><span class="line">            ASEL_REG: alu_a = a;</span><br><span class="line">            ASEL_PC: alu_a = pc;</span><br><span class="line">            ASEL3: alu_a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;core_struct.vh&quot;</span></span><br><span class="line"><span class="keyword">module</span> ALU_Bsel (</span><br><span class="line">    <span class="keyword">input</span> CorePack::data_t b,</span><br><span class="line">    <span class="keyword">input</span> CorePack::alu_asel_op_enum alu_bsel_op,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">63</span>: <span class="number">0</span>] imm,</span><br><span class="line">    <span class="keyword">output</span> CorePack::data_t alu_b</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">import</span> CorePack::*;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> (alu_bsel_op)</span><br><span class="line">            ASEL0: alu_b = <span class="number">0</span>;</span><br><span class="line">            ASEL_REG: alu_b = b;</span><br><span class="line">            ASEL_PC: alu_b = imm;</span><br><span class="line">            ASEL3: alu_b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h4 id="Imm-Gen">Imm Gen</h4>
<p>立即数生成器通过 immgen_op 来截取 inst 的不同部分, 再经过符号扩展生成一个立即数</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>] &#123;</span><br><span class="line">    IMM0,  I_IMM, S_IMM, B_IMM, </span><br><span class="line">    U_IMM, UJ_IMM, IMM6, IMM7</span><br><span class="line">&#125; imm_op_enum;</span><br></pre></td></tr></table></figure>
<ul>
<li>IMM0: 生成一个 0 立即数</li>
<li>I_IMM: 生成一个 I-type 立即数, 区间在 [31: 20], 需要进行符号扩展</li>
<li>S_IMM: 生成一个 S-type 立即数, 区间在 [31: 25, 11: 7], 需要进行符号扩展</li>
<li>B_IMM: 生成一个 B-type 立即数, 区间在 [31, 7, 30: 25, 11: 8], 在最低位补一个 0(保证为偶数), 需要进行符号扩展</li>
<li>U_IMM: 生成一个 U-type 立即数, 区间在 [31: 12], 在高 32 位进行符号扩展, 低 12 位补 0</li>
<li>UJ_IMM: 生成一个 UJ-type 立即数, 区间在 [31, 19: 12, 20, 30: 21], 在最低位补一个 0(保证为偶数), 需要进行符号扩展</li>
<li>IMM6 和 IMM7 无意义</li>
</ul>
<h4 id="Cmp">Cmp</h4>
<p>比较器模块用于进行两个操作数的比较, 比较运算符列表如下</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>] &#123;</span><br><span class="line">    CMP_NO,  CMP_EQ,  CMP_NE,  CMP_LT,</span><br><span class="line">    CMP_GE,  CMP_LTU, CMP_GEU, CMP7</span><br><span class="line">&#125; cmp_op_enum;</span><br></pre></td></tr></table></figure>
<p>对应的代码逻辑如下</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">case</span> (cmp_op)</span><br><span class="line">        CMP_NO: cmp_res = <span class="number">0</span>;</span><br><span class="line">        CMP_EQ: cmp_res = (a == b);</span><br><span class="line">        CMP_NE: cmp_res = (a != b);</span><br><span class="line">        CMP_LT: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (a[DATA_WIDTH - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; b[DATA_WIDTH - <span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">                cmp_res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a[DATA_WIDTH - <span class="number">1</span>] == <span class="number">1</span> &amp;&amp; b[DATA_WIDTH - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">                cmp_res = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a[DATA_WIDTH - <span class="number">1</span>] == b[DATA_WIDTH - <span class="number">1</span>])<span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span> (a[DATA_WIDTH - <span class="number">2</span>: <span class="number">0</span>] &lt; b[DATA_WIDTH - <span class="number">2</span>: <span class="number">0</span>])</span><br><span class="line">                    cmp_res = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> cmp_res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> cmp_res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        CMP_GE: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (a[DATA_WIDTH - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; b[DATA_WIDTH - <span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">                cmp_res = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a[DATA_WIDTH - <span class="number">1</span>] == <span class="number">1</span> &amp;&amp; b[DATA_WIDTH - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">                cmp_res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a[DATA_WIDTH - <span class="number">1</span>] == b[DATA_WIDTH - <span class="number">1</span>])<span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span> (a[DATA_WIDTH - <span class="number">2</span>: <span class="number">0</span>] &gt;= b[DATA_WIDTH - <span class="number">2</span>: <span class="number">0</span>])</span><br><span class="line">                    cmp_res = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> cmp_res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> cmp_res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        CMP_LTU: cmp_res = (a &lt; b);</span><br><span class="line">        CMP_GEU: cmp_res = (a &gt;= b);</span><br><span class="line">        <span class="keyword">default</span>: cmp_res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="Instruction-Selection">Instruction Selection</h4>
<p>指令选择器的作用是选择从内存中读取到的 64bit 的数据的高 / 低 32bit 作为指令(根据 PC 进行截断)</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;core_struct.vh&quot;</span></span><br><span class="line"><span class="keyword">module</span> InstSelector (</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">63</span>: <span class="number">0</span>] ro_rdata,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">63</span>: <span class="number">0</span>] pc,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">31</span>: <span class="number">0</span>] inst</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">        inst = (pc[<span class="number">2</span>] == <span class="number">1&#x27;b0</span>) ? ro_rdata[<span class="number">31</span>: <span class="number">0</span>] : ro_rdata[<span class="number">63</span>: <span class="number">32</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h4 id="Data-Package">Data Package</h4>
<p>为了保证数据在内存中的对齐性, 要通过 Data Package 模块对数据进行打包</p>
<p>根据数据宽度的不同(字节Byte, 半字Halfword, 字word, 双字Doubleword), 和 ALU 的计算结果 alu_res 的低 3bit 对寄存器 dataR2 的数据进行移位</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>] &#123;</span><br><span class="line">    MEM_NO, MEM_D,  MEM_W,  MEM_H,</span><br><span class="line">    MEM_B,  MEM_UB, MEM_UH, MEM_UW</span><br><span class="line">&#125; mem_op_enum;</span><br></pre></td></tr></table></figure>
<h4 id="Data-Mask-Generation">Data Mask Generation</h4>
<p>为了保证数据的有效性, 要通过 Data Mask Generation 模块对数据进行截取</p>
<p>根据数据宽度的不同(字节Byte, 半字Halfword, 字word, 双字Doubleword), 和 ALU 的计算结果 alu_res 的低 3bit 进行掩码的生成</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>] &#123;</span><br><span class="line">    MEM_NO, MEM_D,  MEM_W,  MEM_H,</span><br><span class="line">    MEM_B,  MEM_UB, MEM_UH, MEM_UW</span><br><span class="line">&#125; mem_op_enum;</span><br></pre></td></tr></table></figure>
<h4 id="Data-Truncation">Data Truncation</h4>
<p>数据调整模块对从内存中读取的数据, 按照数据位宽进行截断, 扩展和其他操作, 以扩展到 64bit</p>
<p>主要分为有符号数和无符号数</p>
<ul>
<li>对于有符号数, 按照给定的数据宽度(字节Byte, 半字Halfword, 字word, 双字Doubleword), 从对应的高 / 低相应长度的位置截取数据并作符号扩展</li>
<li>对于无符号数, 截取后直接补零, 也就是作无符号扩展</li>
</ul>
<h4 id="WbSel">WbSel</h4>
<p>WbSel(写回选择) 模块用于根据给定的写回操作类型(wb_sel 的值), 对 ALU 结果, 内存读取结果, PC 内容进行选择</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] &#123;</span><br><span class="line">    WB_SEL0, WB_SEL_ALU, WB_SEL_MEM, WB_SEL_PC</span><br><span class="line">&#125; wb_sel_op_enum;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于 ALU 结果, 根据当前的 opcode, 对 ALU 结果进行扩展
<ul>
<li>只有在 opcode 为寄存器写入 REGW 操作时, 需要进行无符号扩展</li>
</ul>
</li>
<li>对于内存读取结果, 直接回写</li>
<li>对于 PC, 回写 PC + 4 以执行下一条指令</li>
</ul>
<h4 id="PC-和-NPC">PC 和 NPC</h4>
<p>PC(程序计数器)和下一个 NPC(程序计数器)用于计算指令地址的跳转</p>
<p>PC 是一个简单的时序模块, 在每个时钟信号上升沿修改为 NPC 的值</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;core_struct.vh&quot;</span></span><br><span class="line"><span class="keyword">module</span> PC (</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clk,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> rst,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">63</span>: <span class="number">0</span>] pc_in,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">63</span>: <span class="number">0</span>] pc_out</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">always_ff</span> @( <span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> rst ) <span class="keyword">begin</span> : blockName</span><br><span class="line">        <span class="keyword">if</span>(rst) pc_out &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>    pc_out &lt;= pc_in;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>NPC 用于计算 PC 的下一个值, 通过 NPC 选择器 npc_sel 进行选择</p>
<ul>
<li>当 npc_sel 取 0 时, NPC = PC + 4, 即自动跳转到 4Byte 后的地址</li>
<li>当 npc_sel 取 1 时, 表示根据 ALU 结果计算 NPC 的值, 此时需要根据操作码 opcode 进行选择
<ul>
<li>当 opcode 取 JALR(间接跳转) 时, 将最低位清 0 后赋值给 NPC, 以确保 NPC 始终是一个偶数</li>
<li>否则, 直接将 ALU 的结果赋值给 NPC</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;core_struct.vh&quot;</span></span><br><span class="line"><span class="keyword">module</span> NPC (</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">63</span>: <span class="number">0</span>] pc_in,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">63</span>: <span class="number">0</span>] alu,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> npc_sel,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">6</span>: <span class="number">0</span>] opcode,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">63</span>: <span class="number">0</span>] pc_out</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">import</span> CorePack::*;</span><br><span class="line">    <span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (npc_sel) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (opcode == JALR_OPCODE) <span class="keyword">begin</span></span><br><span class="line">                pc_out = alu &amp; <span class="number">64&#x27;hFFFFFFFFFFFFFFFE</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                pc_out = alu;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            pc_out = pc_in + <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h4 id="Core-DataPath">Core(DataPath)</h4>
<p>接下来将上面涉及的所有模块连起来</p>
<ol>
<li><strong>端口</strong></li>
</ol>
<p>模块定义部分</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Core (</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> rst,</span><br><span class="line"></span><br><span class="line">    Mem_ift<span class="variable">.Master</span> imem_ift,</span><br><span class="line">    Mem_ift<span class="variable">.Master</span> dmem_ift,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">output</span> cosim_valid,</span><br><span class="line">    <span class="keyword">output</span> CorePack::CoreInfo cosim_core_info</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>主要关注内存数据交换端口 imem_ift 和 dmem_ift, 两者分别是指令内存接口和数据内存接口, 根据前文提到的内存接口结构分析, 他们的类型是接口(interface), 包含了读写通道成员数据包 r_request_bits 和 w_request_bits</p>
<p>这两个接口也要根据数据通路图接入 Core 模块</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> dmem_ift<span class="variable">.r_request_bits</span><span class="variable">.raddr</span> = alu_res;</span><br><span class="line"><span class="keyword">assign</span> dmem_ift<span class="variable">.r_request_valid</span> = re_mem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> dmem_ift<span class="variable">.w_request_bits</span><span class="variable">.waddr</span> = alu_res;</span><br><span class="line"><span class="keyword">assign</span> dmem_ift<span class="variable">.w_request_valid</span> = we_mem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> imem_ift<span class="variable">.r_request_bits</span><span class="variable">.raddr</span> = pc;</span><br><span class="line"><span class="keyword">assign</span> imem_ift<span class="variable">.r_request_valid</span> = <span class="number">1&#x27;b1</span>; </span><br></pre></td></tr></table></figure>
<ol>
<li><strong>指令切割</strong></li>
</ol>
<p>根据 RISCV ISA Standard 和数据通路图, 可以做出如下切割, 将操作码, 两个源寄存器和目标寄存器的地址分离出来</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> opcode = inst[<span class="number">6</span>:<span class="number">0</span>];</span><br><span class="line"><span class="keyword">assign</span> rs1 = inst[<span class="number">19</span>:<span class="number">15</span>];</span><br><span class="line"><span class="keyword">assign</span> rs2 = inst[<span class="number">24</span>:<span class="number">20</span>];</span><br><span class="line"><span class="keyword">assign</span> rd = inst[<span class="number">11</span>:<span class="number">7</span>];</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>npc_sel</strong></li>
</ol>
<p>NPC 选择器是根据 is_b 和 is_j 信号计算出来的</p>
<p>只有在既不是 is_j, 也不是 is_b, 且 br_taken(分支跳转) 的情况下, npc_sel 才会置 0</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> npc_sel = is_j || (br_taken &amp;&amp; is_b);</span><br></pre></td></tr></table></figure>
<h3 id="Controller-设计">Controller 设计</h3>
<p>对于设计好的单周期 CPU 来说, 除开访存和写回两个步骤要涉及一定的时序, 其他部分只需要应用组合电路的思想就够了</p>
<p>主控模块 Controller 也不例外, 说白了这个模块的作用就是一个大型的译码器, 作用是解码指令, 发出信号, 指挥 DataPath 进行工作</p>
<blockquote>
<p>也就是说, 主控控制的是 DataPath 上的某些开关的开闭, 开关开好了, 这个周期内的数据计算就<strong>可以认为</strong>是完成了</p>
</blockquote>
<h4 id="端口">端口</h4>
<p>控制通路模块的输出是一个 22 位的向量，从最高位到最低为依次定义如下</p>
<blockquote>
<p>也就是说, 主控的功能就是根据 inst 给这些变量赋值</p>
</blockquote>
<h4 id="指令切割">指令切割</h4>
<p>首先对指令进行切割, 分理出操作码 opcode, 功能码 funct3, funct7</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">opcode_t opcode;</span><br><span class="line">funct3_t funct3;</span><br><span class="line">funct7_t funct7;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> opcode = inst[<span class="number">6</span>: <span class="number">0</span>];</span><br><span class="line"><span class="keyword">assign</span> funct3 = inst[<span class="number">14</span>: <span class="number">12</span>];</span><br><span class="line"><span class="keyword">assign</span> funct7 = inst[<span class="number">31</span>: <span class="number">25</span>];</span><br></pre></td></tr></table></figure>
<h4 id="初始化">初始化</h4>
<p>将所有寄存器状态置 0, 或者置为无意义状态</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">we_reg = <span class="number">0</span>;</span><br><span class="line">we_mem = <span class="number">0</span>;</span><br><span class="line">re_mem = <span class="number">0</span>;</span><br><span class="line">is_b = <span class="number">0</span>;</span><br><span class="line">is_j = <span class="number">0</span>;</span><br><span class="line">immgen_op = IMM0;</span><br><span class="line">alu_op = ALU_DEFAULT;</span><br><span class="line">cmp_op = CMP_NO;</span><br><span class="line">alu_asel = ASEL0;</span><br><span class="line">alu_bsel = BSEL0;</span><br><span class="line">wb_sel = WB_SEL0;</span><br><span class="line">mem_op = MEM_NO;</span><br></pre></td></tr></table></figure>
<h4 id="操作码-opcode-支持范围">操作码 opcode 支持范围</h4>
<p>根据 core_struct.vh 的 hint, 需要支持的 opcode 如下</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>] opcode_t;</span><br><span class="line"><span class="keyword">parameter</span> LOAD_OPCODE   = <span class="number">7&#x27;b0000011</span>;</span><br><span class="line"><span class="keyword">parameter</span> IMM_OPCODE    = <span class="number">7&#x27;b0010011</span>;</span><br><span class="line"><span class="keyword">parameter</span> AUIPC_OPCODE  = <span class="number">7&#x27;b0010111</span>;</span><br><span class="line"><span class="keyword">parameter</span> IMMW_OPCODE   = <span class="number">7&#x27;b0011011</span>;</span><br><span class="line"><span class="keyword">parameter</span> STORE_OPCODE  = <span class="number">7&#x27;b0100011</span>;</span><br><span class="line"><span class="keyword">parameter</span> REG_OPCODE    = <span class="number">7&#x27;b0110011</span>;</span><br><span class="line"><span class="keyword">parameter</span> LUI_OPCODE    = <span class="number">7&#x27;b0110111</span>;</span><br><span class="line"><span class="keyword">parameter</span> REGW_OPCODE   = <span class="number">7&#x27;b0111011</span>;</span><br><span class="line"><span class="keyword">parameter</span> BRANCH_OPCODE = <span class="number">7&#x27;b1100011</span>;</span><br><span class="line"><span class="keyword">parameter</span> JALR_OPCODE   = <span class="number">7&#x27;b1100111</span>;</span><br><span class="line"><span class="keyword">parameter</span> JAL_OPCODE    = <span class="number">7&#x27;b1101111</span>;</span><br></pre></td></tr></table></figure>
<h4 id="LOAD-OPCODE">LOAD_OPCODE</h4>
<p>load 指令的作用是通过 rs1 计算得到一个地址, 从内存中加载一个数据, 回写到 rd</p>
<p><code>ld rd, offset(rs1)</code></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">re_mem = <span class="number">1</span>;</span><br><span class="line">we_reg = <span class="number">1</span>;</span><br><span class="line">alu_asel = ASEL_REG;    <span class="comment">// 对应 rs1</span></span><br><span class="line">alu_bsel = BSEL_IMM;    <span class="comment">// 对应 offset</span></span><br><span class="line">alu_op = ALU_ADD;       <span class="comment">// rs1 偏移 offset, ALU 做加法</span></span><br><span class="line">immgen_op = I_IMM;      <span class="comment">// 生成 I 型立即数</span></span><br><span class="line">wb_sel = WB_SEL_MEM;    <span class="comment">// 回写 MEM 的数据</span></span><br></pre></td></tr></table></figure>
<p>根据 funct3, 可以确定内存操作码以适应不同长度的数据, 如 ld, lb, lh 等等(图片不完整)</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> (funct3)</span><br><span class="line">    LB_FUNCT3: mem_op = MEM_B;</span><br><span class="line">    LH_FUNCT3: mem_op = MEM_H;</span><br><span class="line">    LW_FUNCT3: mem_op = MEM_W;</span><br><span class="line">    LD_FUNCT3: mem_op = MEM_D;</span><br><span class="line">    LBU_FUNCT3: mem_op = MEM_UB;</span><br><span class="line">    LHU_FUNCT3: mem_op = MEM_UH;</span><br><span class="line">    LWU_FUNCT3: mem_op = MEM_UW;</span><br><span class="line">    <span class="keyword">default</span>: mem_op = MEM_NO;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<h4 id="REG-OPCODE">REG_OPCODE</h4>
<p>R-type(寄存器操作指令), 通过读取 rs1 和 rs2 的数据, 计算得到的结果回写到 rd</p>
<p><code>add rd, rs1, rs2</code></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">we_reg = <span class="number">1&#x27;b1</span>;          <span class="comment">// 寄存器组写使能</span></span><br><span class="line">alu_asel = ASEL_REG;</span><br><span class="line">alu_bsel = BSEL_REG;    <span class="comment">// ALU 两个操作数均是寄存器</span></span><br><span class="line">wb_sel = WB_SEL_ALU;    <span class="comment">// 回写 ALU 的计算结果</span></span><br></pre></td></tr></table></figure>
<p>根据 funct3 和 funct7(仅 add / sub, srl / sra), 可以确定具体的运算</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> (funct3)</span><br><span class="line">    ADD_FUNCT3: alu_op = (funct7 == <span class="number">7&#x27;b0100000</span>) ? </span><br><span class="line">        ALU_SUB : ALU_ADD;          <span class="comment">// 减法 / 加法</span></span><br><span class="line">    SLT_FUNCT3: alu_op = ALU_SLT;   <span class="comment">// 小于</span></span><br><span class="line">    SLTU_FUNCT3: alu_op = ALU_SLTU; <span class="comment">// 无符号数小于</span></span><br><span class="line">    XOR_FUNCT3: alu_op = ALU_XOR;   <span class="comment">// 异或</span></span><br><span class="line">    OR_FUNCT3: alu_op = ALU_OR;     <span class="comment">// 或</span></span><br><span class="line">    AND_FUNCT3: alu_op = ALU_AND;   <span class="comment">// 与</span></span><br><span class="line">    SLL_FUNCT3: alu_op = ALU_SLL;   <span class="comment">// 逻辑左移</span></span><br><span class="line">    SRL_FUNCT3: alu_op = (funct7 == <span class="number">7&#x27;b0100000</span>) ? </span><br><span class="line">        ALU_SRA : ALU_SRL;          <span class="comment">// 算数 / 逻辑右移</span></span><br><span class="line">    <span class="keyword">default</span>: alu_op = ALU_DEFAULT;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<h4 id="REGW-OPCODE">REGW_OPCODE</h4>
<p>R-type 指令, 通过 rs1 和 rs2 读取有符号数, 作为操作数计算得到的结果, <strong>截取低 32 位</strong>后写回 rd 的低 32 位</p>
<p><code>addw rd, rs1, rs2</code></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">REGW_OPCODE: <span class="keyword">begin</span></span><br><span class="line">    we_reg = <span class="number">1&#x27;b1</span>;          <span class="comment">// 寄存器组写使能</span></span><br><span class="line">    alu_asel = ASEL_REG;    </span><br><span class="line">    alu_bsel = BSEL_REG;    <span class="comment">// 操作数均是寄存器</span></span><br><span class="line">    wb_sel = WB_SEL_ALU;    <span class="comment">// 回写 ALU 的结果</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>因此 WbSel 模块中, 当 wb_sel == WB_SEL_ALU 时, 要额外判断 opcode 是不是 REGW_OPCODE</p>
</blockquote>
<h4 id="IMM-OPCODE">IMM_OPCODE</h4>
<p>I-type 指令, 将立即数与寄存器 rs1 计算得到结果, 写回 rd</p>
<p><code>addi rd, rs1, imm</code></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">we_reg = <span class="number">1&#x27;b1</span>;</span><br><span class="line">alu_asel = ASEL_REG;</span><br><span class="line">alu_bsel = BSEL_IMM;    <span class="comment">// 来源是立即数</span></span><br><span class="line">immgen_op = I_IMM;      <span class="comment">// 产生 I-type 立即数</span></span><br><span class="line">wb_sel = WB_SEL_ALU;</span><br></pre></td></tr></table></figure>
<p>根据 funct3 可以选择具体的运算符</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span>(funct3)</span><br><span class="line">    ADD_FUNCT3: alu_op = ALU_ADD;</span><br><span class="line">    SLT_FUNCT3: alu_op = ALU_SLT;</span><br><span class="line">    SLTU_FUNCT3: alu_op = ALU_SLTU;</span><br><span class="line">    XOR_FUNCT3: alu_op = ALU_XOR;</span><br><span class="line">    OR_FUNCT3: alu_op = ALU_OR;</span><br><span class="line">    AND_FUNCT3: alu_op = ALU_AND;</span><br><span class="line">    SLL_FUNCT3: alu_op = ALU_SLL;</span><br><span class="line">    SRL_FUNCT3: alu_op = (funct7 == <span class="number">7&#x27;b0000000</span>) ? </span><br><span class="line">        ALU_SRL : ALU_SRA;</span><br><span class="line">    <span class="keyword">default</span>: alu_op = ALU_DEFAULT;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<h4 id="IMMW-OPCODE">IMMW_OPCODE</h4>
<p>通过 rs1 和 rs2 读取有符号数, 作为操作数计算得到的结果写回 rd</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">we_reg = <span class="number">1&#x27;b1</span>;</span><br><span class="line">alu_asel = ASEL_REG;</span><br><span class="line">alu_bsel = BSEL_IMM;</span><br><span class="line">immgen_op = I_IMM;</span><br><span class="line">wb_sel = WB_SEL_ALU;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> (funct3)</span><br><span class="line">    ADDW_FUNCT3: alu_op = ALU_ADDW;</span><br><span class="line">    SLLW_FUNCT3: alu_op = ALU_SLLW;</span><br><span class="line">    SRLW_FUNCT3: alu_op = (funct7 == <span class="number">7&#x27;b0000000</span>) ? </span><br><span class="line">        ALU_SRLW : ALU_SRAW;</span><br><span class="line">    <span class="keyword">default</span>: alu_op = ALU_DEFAULT;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<h4 id="STORE-OPCODE">STORE_OPCODE</h4>
<p>S-type 指令, 通过立即数和 rs1 相加得到一个地址, 再将 rs2 的值写入这个地址(内存)</p>
<p><code>sd rs2, imm(rs1)</code></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">we_mem = <span class="number">1</span>;             <span class="comment">// 内存写使能</span></span><br><span class="line">alu_asel = ASEL_REG;</span><br><span class="line">alu_bsel = BSEL_IMM;</span><br><span class="line">alu_op = ALU_ADD;       <span class="comment">// 只有加法</span></span><br><span class="line">immgen_op = S_IMM;      <span class="comment">// 生成 S-type 立即数</span></span><br><span class="line">wb_sel = WB_SEL_ALU;    <span class="comment">// 回写 ALU 结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> (funct3)           <span class="comment">// funct3 确定回写数据的位宽</span></span><br><span class="line">    SB_FUNCT3: mem_op = MEM_B;</span><br><span class="line">    SH_FUNCT3: mem_op = MEM_H;</span><br><span class="line">    SW_FUNCT3: mem_op = MEM_W;</span><br><span class="line">    SD_FUNCT3: mem_op = MEM_D;</span><br><span class="line">    <span class="keyword">default</span>: mem_op = MEM_NO;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<h4 id="BRANCH-OPCODE">BRANCH_OPCODE</h4>
<p>B-type 指令, 比较 rs1 和 rs2 的值, 假如返回值为真, 则跳转到 PC + imm 处, 否则顺序执行 PC + 4</p>
<p><code>blt rs1, rs2</code></p>
<p>对于 B-type 指令来说, 核心就不是 ALU 了, 而是 Cmp</p>
<p>在主控部分只涉及前面一段话的一小部分的实现(PC + imm), 至于如何比较, 是通过 is_b 将信号传递给 Cmp(同时还有比较操作码 cmp_opcode ), 再由 Cmp 输出 br_taken 信号给 NPC, 让 NPC 选择跳转到 PC + 4 还是 ALU 的运算结果 (PC + imm)</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">is_b = <span class="number">1</span>;               <span class="comment">// 比较器使能</span></span><br><span class="line">alu_asel = ASEL_PC;     <span class="comment">// 操作数 PC</span></span><br><span class="line">alu_bsel = BSEL_IMM;    <span class="comment">// 操作数立即数</span></span><br><span class="line">alu_op = ALU_ADD;       <span class="comment">// 加法</span></span><br><span class="line">immgen_op = B_IMM;      <span class="comment">// 生成 B-type 立即数</span></span><br><span class="line">wb_sel = WB_SEL_ALU;    <span class="comment">// 回写 ALU 计算结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> (funct3)   <span class="comment">// 根据 funct3 确定 cmp_op</span></span><br><span class="line">    BEQ_FUNCT3: cmp_op = CMP_EQ;</span><br><span class="line">    BNE_FUNCT3: cmp_op = CMP_NE;</span><br><span class="line">    BLT_FUNCT3: cmp_op = CMP_LT;</span><br><span class="line">    BGE_FUNCT3: cmp_op = CMP_GE;</span><br><span class="line">    BLTU_FUNCT3: cmp_op = CMP_LTU;</span><br><span class="line">    BGEU_FUNCT3: cmp_op = CMP_GEU;</span><br><span class="line">    <span class="keyword">default</span>: cmp_op = CMP_NO;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<h4 id="JAL-OPCODE">JAL_OPCODE</h4>
<p>UJ-type 指令, 生成立即数, 跳转到 imm 作为地址的内存位置, 并回写原本的下一条指令的地址到 rd</p>
<blockquote>
<p>也就是执行了 <code>rd = PC + 4; PC = PC + imm;</code></p>
</blockquote>
<p><code>jar rd, imm</code></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">is_j = <span class="number">1</span>;           <span class="comment">// 跳转使能</span></span><br><span class="line">we_reg = <span class="number">1</span>;         <span class="comment">// 寄存器写使能</span></span><br><span class="line">wb_sel = WB_SEL_PC; <span class="comment">// 回写 PC(实际上回写了 PC + 4)</span></span><br><span class="line">alu_op = ALU_ADD;   <span class="comment">// 加法</span></span><br><span class="line"></span><br><span class="line">alu_asel = ASEL_PC;</span><br><span class="line">alu_bsel = BSEL_IMM;</span><br><span class="line">immgen_op = UJ_IMM; <span class="comment">// 生成 UJ-type 立即数</span></span><br></pre></td></tr></table></figure>
<h4 id="JALR-OPCODE">JALR_OPCODE</h4>
<p>I-type 指令, 生成立即数, 跳转到 rs1 + imm 处, 并回写原本的下一条指令的地址到 rd</p>
<blockquote>
<p>也就是执行了 <code>rd = PC + 4; PC = rs1 + imm;</code></p>
</blockquote>
<p><code>jalr rd, rs1, imm</code></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">JAL_OPCODE, JALR_OPCODE: <span class="keyword">begin</span></span><br><span class="line">    is_j = <span class="number">1</span>;           <span class="comment">// 跳转使能</span></span><br><span class="line">    we_reg = <span class="number">1</span>;         <span class="comment">// 寄存器写使能</span></span><br><span class="line">    wb_sel = WB_SEL_PC; <span class="comment">// 回写 PC(实际上回写了 PC + 4)</span></span><br><span class="line">    alu_op = ALU_ADD;   <span class="comment">// 加法</span></span><br><span class="line">    alu_asel = ASEL_REG;</span><br><span class="line">    alu_bsel = BSEL_IMM;</span><br><span class="line">    immgen_op = I_IMM;  <span class="comment">// 生成 I-type 立即数</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="LUI-OPCODE">LUI_OPCODE</h4>
<p>U-type 指令, 生成立即数, 加载到 rd 的高 20 位, 低位全部置 0</p>
<p><code>lui rd, imm</code></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">we_reg = <span class="number">1&#x27;b1</span>;          <span class="comment">// 寄存器写使能</span></span><br><span class="line">immgen_op = U_IMM;      <span class="comment">// 生成 U-type 立即数</span></span><br><span class="line">alu_bsel = BSEL_IMM;</span><br><span class="line">alu_op = ALU_ADD;</span><br><span class="line">wb_sel = WB_SEL_ALU;    <span class="comment">// 回写 ALU 结果</span></span><br></pre></td></tr></table></figure>
<h4 id="AUIPC-OPCODE">AUIPC_OPCODE</h4>
<p>U-type 指令, 生成立即数, 左移成 32 位, 再加上当前 PC 的值, 储存到 rd 的高 32 位</p>
<p><code>auipc rd, imm</code></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">we_reg = <span class="number">1&#x27;b1</span>;</span><br><span class="line">alu_asel = ASEL_PC;</span><br><span class="line">alu_bsel = BSEL_IMM;</span><br><span class="line">immgen_op = U_IMM;</span><br><span class="line">alu_op = ALU_ADD;</span><br><span class="line">wb_sel = WB_SEL_ALU;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://z-vanadium.github.io">Vanadium</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://z-vanadium.github.io/2024/06/24/sys1-lab/">http://z-vanadium.github.io/2024/06/24/sys1-lab/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://z-vanadium.github.io" target="_blank">Vanadium的小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://www.imageoss.com/images/2024/03/28/f619d119ea8babb02498e3a91bdf9688ce395db803fc4641891cfa98.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/16/civ-1/" title="文明 6 游戏机制"><img class="cover" src="https://www.imageoss.com/images/2024/03/28/v2-334cc816fbe737fd332d1f9e6ecec3cf_r28744eb27865ab1e.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">文明 6 游戏机制</div></div></a></div><div class="next-post pull-right"><a href="/2024/05/16/cpp-perfect-forwarding/" title="C++ | 完美转发"><img class="cover" src="https://www.imageoss.com/images/2024/03/29/srchttp___c-ssl.duitang.com_uploads_item_202002_28_20200228001029_hhpox.thumb.1000_0.jpgreferhttp___c-ssl.duitang772cd8c70be78029.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++ | 完美转发</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://www.imageoss.com/images/2024/03/27/avatar84f10990023d148a.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Vanadium</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Z-Vanadium"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome to Vanadium's Blog!<br>
ZJUer | Freshman | IS | 术力口 | 摸鱼 | OP
</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-number">1.</span> <span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.</span> <span class="toc-text">数据通路设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Memory"><span class="toc-number">2.1.</span> <span class="toc-text">Memory</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RegFile"><span class="toc-number">2.2.</span> <span class="toc-text">RegFile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ALU"><span class="toc-number">2.3.</span> <span class="toc-text">ALU</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ALU-asel-%E5%92%8C-ALU-bsel"><span class="toc-number">2.4.</span> <span class="toc-text">ALU_asel 和 ALU_bsel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Imm-Gen"><span class="toc-number">2.5.</span> <span class="toc-text">Imm Gen</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cmp"><span class="toc-number">2.6.</span> <span class="toc-text">Cmp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Instruction-Selection"><span class="toc-number">2.7.</span> <span class="toc-text">Instruction Selection</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Data-Package"><span class="toc-number">2.8.</span> <span class="toc-text">Data Package</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Data-Mask-Generation"><span class="toc-number">2.9.</span> <span class="toc-text">Data Mask Generation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Data-Truncation"><span class="toc-number">2.10.</span> <span class="toc-text">Data Truncation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WbSel"><span class="toc-number">2.11.</span> <span class="toc-text">WbSel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PC-%E5%92%8C-NPC"><span class="toc-number">2.12.</span> <span class="toc-text">PC 和 NPC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Core-DataPath"><span class="toc-number">2.13.</span> <span class="toc-text">Core(DataPath)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Controller-%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.</span> <span class="toc-text">Controller 设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3"><span class="toc-number">3.1.</span> <span class="toc-text">端口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%88%87%E5%89%B2"><span class="toc-number">3.2.</span> <span class="toc-text">指令切割</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.3.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%A0%81-opcode-%E6%94%AF%E6%8C%81%E8%8C%83%E5%9B%B4"><span class="toc-number">3.4.</span> <span class="toc-text">操作码 opcode 支持范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LOAD-OPCODE"><span class="toc-number">3.5.</span> <span class="toc-text">LOAD_OPCODE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#REG-OPCODE"><span class="toc-number">3.6.</span> <span class="toc-text">REG_OPCODE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#REGW-OPCODE"><span class="toc-number">3.7.</span> <span class="toc-text">REGW_OPCODE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IMM-OPCODE"><span class="toc-number">3.8.</span> <span class="toc-text">IMM_OPCODE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IMMW-OPCODE"><span class="toc-number">3.9.</span> <span class="toc-text">IMMW_OPCODE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#STORE-OPCODE"><span class="toc-number">3.10.</span> <span class="toc-text">STORE_OPCODE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BRANCH-OPCODE"><span class="toc-number">3.11.</span> <span class="toc-text">BRANCH_OPCODE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JAL-OPCODE"><span class="toc-number">3.12.</span> <span class="toc-text">JAL_OPCODE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JALR-OPCODE"><span class="toc-number">3.13.</span> <span class="toc-text">JALR_OPCODE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LUI-OPCODE"><span class="toc-number">3.14.</span> <span class="toc-text">LUI_OPCODE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AUIPC-OPCODE"><span class="toc-number">3.15.</span> <span class="toc-text">AUIPC_OPCODE</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/3939/03/09/bulletin-board/" title="Vanadium的小屋御用公告板">Vanadium的小屋御用公告板</a><time datetime="3939-03-08T19:09:39.000Z" title="发表于 3939-03-09 03:09:39">3939-03-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/12/ads-index/" title="高级数据结构与算法分析">高级数据结构与算法分析</a><time datetime="2024-09-11T16:00:00.000Z" title="发表于 2024-09-12 00:00:00">2024-09-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/12/crypto-index/" title="数据安全与密码学基础">数据安全与密码学基础</a><time datetime="2024-09-11T16:00:00.000Z" title="发表于 2024-09-12 00:00:00">2024-09-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/12/oop/" title="面向对象程序设计">面向对象程序设计</a><time datetime="2024-09-11T16:00:00.000Z" title="发表于 2024-09-12 00:00:00">2024-09-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/08/civ6-mod-make-3/" title="文明 6 mod 制作学习笔记 (3) 新的文明">文明 6 mod 制作学习笔记 (3) 新的文明</a><time datetime="2024-08-08T06:33:11.653Z" title="发表于 2024-08-08 14:33:11">2024-08-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/07/civ6-mod-make-2/" title="文明 6 mod 制作学习笔记 (2) 新的单位">文明 6 mod 制作学习笔记 (2) 新的单位</a><time datetime="2024-08-07T08:58:59.037Z" title="发表于 2024-08-07 16:58:59">2024-08-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/07/civ6-mod-make-1/" title="文明 6 mod 制作学习笔记 (1) 从水下第一个 mod 开始">文明 6 mod 制作学习笔记 (1) 从水下第一个 mod 开始</a><time datetime="2024-08-07T07:48:33.537Z" title="发表于 2024-08-07 15:48:33">2024-08-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/21/prototype-chain-pollution-vulnerability-in-js/" title="Javascript 中的原型链污染漏洞">Javascript 中的原型链污染漏洞</a><time datetime="2024-07-20T20:40:11.000Z" title="发表于 2024-07-21 04:40:11">2024-07-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/16/civ-1/" title="文明 6 游戏机制">文明 6 游戏机制</a><time datetime="2024-07-15T22:31:04.000Z" title="发表于 2024-07-16 06:31:04">2024-07-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/24/sys1-lab/" title="Computer System I Lab project 实验报告">Computer System I Lab project 实验报告</a><time datetime="2024-06-24T13:01:50.046Z" title="发表于 2024-06-24 21:01:50">2024-06-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By Vanadium</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>