
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>C++ | 智能指针 | Vanadium的小屋</title>
    <meta name="author" content="Vanadium" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.1.1"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>VANADIUM的小屋</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;主页</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;关于</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;归档</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;分类</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;标签</span>
        </a>
        
        <a href="/categories/%E7%AC%94%E8%AE%B0/">
            <i class="fa-solid fa-note-sticky fa-fw"></i>
            <span>&ensp;笔记</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;VANADIUM的小屋</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">主页</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">关于</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">归档</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">分类</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">标签</div>
                    </div>
                </a>
                
                <a href="/categories/%E7%AC%94%E8%AE%B0/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-note-sticky fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">笔记</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <!--card-->
<div class="right-infos">

    <div id="home-card-in-post">    
        <div id="home-card">
        <div id="card-style">
    <div id="card-div">
        <div class="avatar">
            <img src="/images/avatar.jpg" alt="avatar" />
        </div>
        <div class="name">Vanadium</div>
        <div class="description">
            <p>ZJUer | Freshman | IS | 术力口 | 摸鱼 | OP</p>

        </div>
        
        
    </div>
</div>

        </div>
    </div>

    <div id="toc" class="toc-article">
        <div class="toc-title">目录</div>
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BC%95%E5%85%A5-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">1 引入: 为什么我们需要智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E9%97%AE%E9%A2%98%E4%B8%80"><span class="toc-text">1.1 问题一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E9%97%AE%E9%A2%98%E4%BA%8C"><span class="toc-text">1.2 问题二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E6%8C%87%E9%92%88%E5%8C%85%E5%90%AB%E4%BA%86%E5%A4%AA%E5%A4%9A%E4%BF%A1%E6%81%AF"><span class="toc-text">1.3 指针包含了太多信息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">2 垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%AF%E8%BE%BE%E6%80%A7"><span class="toc-text">2.1 对象的可达性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%9B%9E%E6%94%B6%E5%A4%9A%E5%B0%91%E5%86%85%E5%AD%98"><span class="toc-text">2.2 回收多少内存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-std-unique-ptr"><span class="toc-text">3 std::unique_ptr</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-text">3.1 实现思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-std-make-unique"><span class="toc-text">3.2 std::make_unique()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.3 数组类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E6%89%80%E6%9C%89%E6%9D%83%E8%BD%AC%E7%A7%BB"><span class="toc-text">3.4 所有权转移</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-std-shared-ptr"><span class="toc-text">4 std::shared_ptr</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E6%8E%A5%E5%8F%A3"><span class="toc-text">4.1 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-std-make-shared"><span class="toc-text">4.2 std::make_shared()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E6%89%80%E6%9C%89%E6%9D%83%E8%BD%AC%E7%A7%BB"><span class="toc-text">4.3 所有权转移</span></a></li></ol></li></ol>
    </div>      
</div>
<!--end-->

<div class="article">
    <div>
        <h1>C++ | 智能指针</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/3/24
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/C-C/" style="color: #ff7d73">C/C++</a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <blockquote>
<p>这是 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1SN411y7qk/?spm_id_from=333.788&amp;vd_source=fb60086411a6996e53c3014541e4a3ee">C++ 网课</a>学习笔记</p>
<p>建议先阅读上一节 <code>右值引用 &amp; 移动语义</code> 或对内容有一定了解后再来阅读本篇笔记</p>
</blockquote>
<span id="more"></span>
<!--
<img src="https://raw.githubusercontent.com/Z-Vanadium/Z-Vanadium.github.io/main/ImageHost/Illustrations/FILENAME.XXX">
-->
<p> </p>
<h3 id="1-引入-为什么我们需要智能指针">1 引入: 为什么我们需要智能指针</h3>
<h4 id="1-1-问题一">1.1 问题一</h4>
<p>观察以下代码</p>
<pre><code class="language-c++">void science(double* data, int N) &#123;
    double* temp = new double[N*2];
    do_setup(data, temp, N);
    if (!needed(data, temp, N))
        return;
    calculate(data, temp, N);
    delete[] temp;
&#125;
</code></pre>
<p>不难理解, 函数 <code>science()</code> 接受两个参数, 一个表示数组 <code>data</code> 的首元素地址, 一个表示数组的长度</p>
<p>这说明了一个数组类型包含了三个信息: 数组元素类型, 首元素地址和长度; 然而当我们把数组作为指针传入时, 我们却丧失了长度这个信息, 只能用一个额外的 <code>N</code> 储存这个信息</p>
<p>回到函数体本身, 这个函数实现的功能很简单, 假如 <code>needed()</code> 为真, 则对 <code>data</code> 调用 <code>calculate()</code>. 但是这个函数却有一个很大很大的缺陷, 假如 <code>needed()</code> 为假, 我们 new 出来的 <code>temp</code> 指针所指向的地址的内容就无法被释放, 成为垃圾了</p>
<div class="tips">
<p>这是传统指针遇到的第一个问题, 我们无法通过指针类型判断一个指针应该在什么时候被释放</p>
</div>
<p> </p>
<h4 id="1-2-问题二">1.2 问题二</h4>
<pre><code class="language-c++">float* science(float* x, float* y, int N) &#123;
    float* z = new float[N];
    saxpy(2.5, x, y, z, N);
    delete[] x;
    delete[] y;
    return z;
&#125;
</code></pre>
<p>这个函数也不难理解, 我们通过 x 和 y 计算出了 z, 同时 x 和 y 在函数内部就被释放了, 而 z 被保留, 这些东西都需要用户自己清楚, 很可能导致 UB</p>
<div class="tips">
<p>这是传统指针遇到的第二个问题, 传统指针是用户不友好的, 很多信息你只能在代码层面解读, 而无法从接口层告知</p>
</div>
<p> </p>
<h4 id="1-3-指针包含了太多信息">1.3 指针包含了太多信息</h4>
<ol>
<li class="lvl-3">
<p>对于单个对象或数组</p>
<ul class="lvl-2">
<li class="lvl-5">单个对象: 我们使用 new 和 delete, 不支持 ++, – 或 []</li>
<li class="lvl-5">数组: 我们使用 new[] 和 delete[], 支持 ++, – 或 []</li>
</ul>
<div class="tips">
<p>然而不管指向什么东西的指针, 他们都长一个样: <code>T*</code>, 但是我们却需要根据其指向对象的类型的不同使用不同的操作, 这显然是不友好的</p>
</div>
</li>
<li class="lvl-3">
<p>所有权</p>
<ul class="lvl-2">
<li class="lvl-5">所有者必须在使用完成后及时释放内存</li>
<li class="lvl-5">非所有者无权释放内存</li>
</ul>
<blockquote>
<p>防止没有释放导致浪费或重复释放导致出错</p>
</blockquote>
</li>
<li class="lvl-3">
<p>是否可以为空</p>
</li>
</ol>
<details open>
<summary><span class="pre-summary">&nbsp;</span>Summary</summary><p>正是因为指针包括了很多很多无法简单被类型描述的特征, 这些特征又是刚需的, 所以我们需求一种 <strong>智能</strong> 的指针</p>
<ul class="lvl-1">
<li class="lvl-2">他知道使用 <code>delete</code> / <code>delete[]</code></li>
<li class="lvl-2">生命周期结束后自动销毁</li>
<li class="lvl-2">是否可以为空指针</li>
</ul>
</details>
<div class="success">
<p>其实, STL 容器就包含了这种 <strong>智能</strong> , 我们只负责调用某个容器, 如 <code>string</code>, 而并不关心它什么时候销毁, 或者是否可以为空和销毁方式</p>
</div>
<p> </p>
<h3 id="2-垃圾回收">2 垃圾回收</h3>
<blockquote>
<p>回收不可达的对象</p>
</blockquote>
<h4 id="2-1-对象的可达性">2.1 对象的可达性</h4>
<p>首先第一个问题就是, 如何判断一个对象的可达性?</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>维护一个 reference counting, 每有一个指针指向这个对象, 就 ++, 否则就 –</p>
</li>
<li class="lvl-2">
<p>周期运行 mark-and-sweep (from root set), 每次运行的时候, 通过递归的方式标记有哪些内存是可访问的, 回收其他所有不可达的内存</p>
</li>
</ul>
<p> </p>
<h4 id="2-2-回收多少内存">2.2 回收多少内存</h4>
<p>第二个问题是, 回收多少内存空间</p>
<div class="warning">
<p>C++ 并不是一个类型安全的语言</p>
</div>
<ul class="lvl-0">
<li class="lvl-2">
<p>例如一个 <code>void*</code> 类型指针指向某个地址, 当我们回收它时, 我们并不知道具体要回收多少内存</p>
</li>
</ul>
<p> </p>
<h3 id="3-std-unique-ptr">3 std::unique_ptr</h3>
<pre><code class="language-c++">#include&lt;memory&gt;
</code></pre>
<p><code>unique_ptr</code> 假设自己是对象唯一的所有者(由用户保证), 这样就能保证 unique_ptr 在析构的时候可以直接释放, 不用考虑其他指针</p>
<div class="tips">
<p>正因如此, <code>unique_ptr</code> 无法被拷贝, 只能移动</p>
<pre><code class="language-c++">std::unique_ptr&lt;T&gt; p(new T(/* some parameters */)), q;
p-&gt;member();
q = std::move(p);   // legal behaviour
q = p;              // illegal behaviour
</code></pre>
</div>
<p>举个栗子</p>
<pre><code class="language-c++">WidgetBase* create_widget(InputType);
 
class MyClass &#123;
    std::unique_ptr&lt;WidgetBase&gt; owner;
public:
    MyClass(InputType inputs)
        : owner(create_widget(inputs)) &#123; &#125;
    ~MyClass() = default;
    // ... member functions that use owner-&gt; ...
&#125;;
</code></pre>
<p>在这个代码段里面, 我们定义了一个 <code>MyClass</code> 类, 拥有一个私有成员 <code>owner</code>, 类型是 <code>unique_ptr</code></p>
<p>MyClass 的构造函数利用了一个返回值为 <code>WidgetBase*</code> 类型的辅助函数 <code>create_widget()</code>, 为 <code>owner</code> 提供具体的构造实现</p>
<p>值得注意的是, 在析构函数里面, 我们只用 <code>~MyClass() = default;</code>, 而无需自己做内存释放, 这是因为一旦自己的生命周期结束, 作为 <code>unique_ptr</code> 的成员变量 <code>owner</code> 就会自己消亡, 递归的 <code>delete</code> / <code>delete[]</code> 属于 <code>owner</code> 的内存</p>
<div class="warning">
<p>因为 <code>unique_ptr</code> 的不可拷贝的特点, <code>MyClass</code> 将无法拥有拷贝构造函数</p>
</div>
<p> </p>
<h4 id="3-1-实现思路">3.1 实现思路</h4>
<p>成员类型</p>
<pre><code class="language-c++">template &lt;typename T&gt;
struct unique_ptr &#123;
    // ...
    using element_type = T; // 指向对象的类型
    using pointer = T*;     // 本身的指针类型
    // ...
&#125;;
</code></pre>
<p>构造与析构</p>
<pre><code class="language-c++">template &lt;typename T&gt;
class unique_ptr &#123;
    T* ptr;
public:
    unique_ptr() noexcept : ptr(nullptr) &#123; &#125;    // 说明 unique_ptr 是可为空的
    explicit unique_ptr(T* p) noexcept : ptr(p) &#123; &#125; // 假如接受了一个 T*, 则利用 T* 去构造 ptr
    ~unique_ptr() noexcept &#123; delete ptr; &#125;  // 析构函数
    // ...
&#125;;
</code></pre>
<p>移动构造与移动赋值</p>
<pre><code class="language-c++">template &lt;typename T&gt; struct unique_ptr &#123;
    // ...
    unique_ptr(unique_ptr const&amp;) = delete;
    unique_ptr&amp; operator=(unique_ptr const&amp;) = delete;
    // 拷贝构造和拷贝赋值均被删除了
 
    unique_ptr(unique_ptr&amp;&amp; o) noexcept
        : ptr(std::exchange(o.ptr, nullptr)) &#123; &#125;
    // 移动构造就是交换接收到的 unique_ptr&amp;&amp; 和目标的 ptr
    unique_ptr&amp; operator=(unique_ptr&amp;&amp; o) noexcept &#123;
        delete ptr;         // 回收被赋值指针的 ptr
        ptr = o.ptr;        // 做交换
        o.ptr = nullptr;
        return *this;       // 返回本身的引用
    &#125;
    // ...
&#125;;
</code></pre>
<p>重载运算符</p>
<pre><code class="language-c++">template &lt;typename T&gt;
struct unique_ptr &#123;
    // ...
    T&amp; operator*() const noexcept &#123;
        return *ptr;
    &#125;
    T* operator-&gt;() const noexcept &#123;
        return ptr;
    &#125;
    // ...
    &#125;;
</code></pre>
<p>其他成员函数</p>
<pre><code class="language-c++">template &lt;typename T&gt; struct unique_ptr &#123;
    // 释放 ptr, 并返回一个指向 ptr 指向的对象的指针 old
    T* release() noexcept &#123;
        T* old = ptr;
        ptr = nullptr;
        return old;
    &#125;
    // 重置 ptr 为 p
    void reset(T* p = nullptr) noexcept &#123;
        delete ptr;
        ptr = p;
    &#125;
    // 获得指针 ptr
    T* get() const noexcept &#123; 
        return ptr; 
    &#125;
    // 判断是否为空指针
    explicit operator bool() const noexcept &#123;
        return ptr != nullptr;
    &#125;
&#125;;
</code></pre>
<details open>
<summary><span class="pre-summary">&nbsp;</span>Summary</summary><p>实际上, unique_ptr 就是它的成员 ptr 的一个包装, 通过特定的基本函数和运算符重载使他具有一定的特性–智能</p>
</details>
<p> </p>
<h4 id="3-2-std-make-unique">3.2 std::make_unique()</h4>
<p>回顾之前的一段实例代码</p>
<pre><code class="language-c++">std::unique_ptr&lt;T&gt; p(new T(/* some parameters */)), q;
p-&gt;member();
q = std::move(p);   // legal behaviour
q = p;              // illegal behaviour
</code></pre>
<div class="danger">
<p>我们发现一个很别扭的事情: 有 <code>new</code>, 却没有 <code>delete</code></p>
</div>
<p>这种不美观的事情 C++ 是不愿意看到的, 因此 C++11 引入了 <code>make_unique()</code> 函数把 <code>std::unique_ptr&lt;T&gt; p(new T(/* some parameters */)), q;</code> 改写为:</p>
<pre><code class="language-c++">auto p = std::make_unique&lt;T&gt;(/* some parameters */);
</code></pre>
<div class="tips">
<p>NO MORE RAW NEW!!!</p>
</div>
<p><code>make_unique</code> 内部实现如下:</p>
<pre><code class="language-c++">template &lt;typename T, typename... Args&gt;
unique_ptr&lt;T&gt; make_unique(Args&amp;&amp;... args);
</code></pre>
<blockquote>
<p>类似于完美转发</p>
</blockquote>
<p> </p>
<h4 id="3-3-数组类型">3.3 数组类型</h4>
<p>事实上, <code>std::unique_ptr</code> 也为数组类型做出了偏特化 <code>std::unique_otr&lt;T[]&gt;</code></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>在析构函数中, 默认使用 <code>delete[]</code>, 而不是 <code>delete</code></p>
</li>
<li class="lvl-2">
<p>提供了 <code>operator[]</code></p>
</li>
</ul>
<p>同时, <code>std::make_unique</code> 也为数组类型做了偏特化</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>接受的参数是数组大小而非构造函数参数</p>
</li>
</ul>
<p>有了这么多工具, 我们就可以对</p>
<pre><code class="language-c++">void science(double* data, int N) &#123;
    double* temp = new double[N*2];
    do_setup(data, temp, N);
    if (!needed(data, temp, N))
        return;
    calculate(data, temp, N);
    delete[] temp;
&#125;
</code></pre>
<p>进行升级了:</p>
<pre><code class="language-c++">void science(double* data, int N) &#123;
    auto temp = std::make_unique&lt;double[]&gt;(N * 2);  // duoble[] 说明这是一个 double 类型的数组指针

    // 利用 temp.get() 代替原来的 temp, 不改变 do_setup 的接口
    do_setup(data, temp.get(), N);
    if (!needed(data, temp.get(), N))
        return;
    calculate(data, temp.get(), N);
    // 不论是如何退出函数, temp 都会被正常析构
&#125;
</code></pre>
<p> </p>
<h4 id="3-4-所有权转移">3.4 所有权转移</h4>
<p>由于 <code>unique_ptr</code> 的所有权是 unique 的, 所以, 我们可以通过上一节中学习的移动构造或移动赋值函数完成所有权的转移</p>
<pre><code class="language-c++">auto a = std::make_unique&lt;T&gt;();
// ...
std::unique_ptr&lt;T&gt; b&#123; std::move(a) &#125;;   // 利用移动语义
// ...
a = std::move(b);
</code></pre>
<p>回到之前被诟病的代码:</p>
<pre><code class="language-c++">float* science(float* x, float* y, int N) &#123;
    float* z = new float[N];
    saxpy(2.5, x, y, z, N);
    delete[] x;
    delete[] y;
    return z;
&#125;
</code></pre>
<p>我们之前认为其无法清晰的向用户表达信息的转移和变化, 但是智能指针可以, 升级如下:</p>
<pre><code class="language-c++">std::unique_ptr&lt;float[]&gt; science(
        std::unique_ptr&lt;float[]&gt; x,
        std::unique_ptr&lt;float[]&gt; y, int N) &#123;
    auto z = std::make_unique&lt;float[]&gt;(N);
    saxpy(2.5, x.get(), y.get(), z.get(), N);
    return z;
&#125;

int main()&#123;
    // ...
    auto result = science(std::move(upx), std::move(upy), N);
    // ...
&#125;
</code></pre>
<p>这样, 在用户调用这个函数的时候, 就能清晰的知道, <code>upx</code> 和 <code>upy</code> 作为参数, 只能用右值引用的方式赋予, 用户一下就明白这个所有权实际上交接给了函数内部</p>
<div class="tips">
<p>需要给一个函数传递所有权时或需要从一个函数返回所有权时，按值传递 <code>unique_ptr</code></p>
</div>
<pre><code class="language-c++">unique_ptr&lt;widget&gt; factory();               // 返回所有权
void sink( unique_ptr&lt;widget&gt; );            // 交付所有权
void reseat( unique_ptr&lt;widget&gt;&amp; );         // 可能要 reset ptr
void thinko( const unique_ptr&lt;widget&gt;&amp; );   // 一般不使用
</code></pre>
<div class="warning">
<p>不是所有地方都要用智能指针的, 在不涉及所有权转移的地方, 可以继续使用指针和引用</p>
</div>
<p> </p>
<h3 id="4-std-shared-ptr">4 std::shared_ptr</h3>
<blockquote>
<p>顾名思义, 这是可以共享的 <code>unique_ptr</code></p>
</blockquote>
<pre><code class="language-c++">#include&lt;memory&gt;
</code></pre>
<p><code>shared_ptr</code> 是对象的所有者(但不唯一), 当且仅当指向该对象的最后一个 <code>shared_ptr</code> 不再指向它时, 对象被释放</p>
<div class="tips">
<p>可以被拷贝!</p>
</div>
<p> </p>
<h4 id="4-1-接口">4.1 接口</h4>
<blockquote>
<p>具体实现比较麻烦, 略去不讲</p>
</blockquote>
<pre><code class="language-c++">template &lt;typename T&gt;
struct shared_ptr &#123;
    // ...
    shared_ptr() noexcept;      // Creates empty shared_ptr
    explicit shared_ptr(T*);    // Starts managing an object
    ~shared_ptr() noexcept;     // Decrements count, and ...
                                // Cleanup if count == 0
    // ...
&#125;;
</code></pre>
<p>拷贝构造和移动构造</p>
<pre><code class="language-c++">template &lt;typename T&gt;
struct shared_ptr &#123;
    // ...
    shared_ptr(shared_ptr const&amp;) noexcept;     // copy ptrs, count++
    shared_ptr(shared_ptr&amp;&amp;) noexcept;          // transfer ownership
    shared_ptr(unique_ptr&lt;T&gt;&amp;&amp;);                // transfer ownership
    
    // origin count will decrease, possibly cleanup:
    shared_ptr&amp; operator=(shared_ptr const&amp;) noexcept;
    shared_ptr&amp; operator=(shared_ptr&amp;&amp;) noexcept;
    shared_ptr&amp; operator=(unique_ptr&lt;T&gt;&amp;&amp;);
    // ...
&#125;;
</code></pre>
<p>其他成员函数</p>
<pre><code class="language-c++">template &lt;typename T&gt;
struct shared_ptr &#123;
// ...
    T&amp; operator*() const noexcept;
    T* operator-&gt;() const noexcept;

    void reset(T*);
    T* get() const noexcept;
    long use_count() const noexcept;    // 获取管理的对象被指向数
    explicit operator bool() const noexcept;
// ...
&#125;;
</code></pre>
<p> </p>
<h4 id="4-2-std-make-shared">4.2 std::make_shared()</h4>
<pre><code class="language-c++">template &lt;typename T, typename... Args&gt;
shared_ptr&lt;T&gt; make_shared(Args&amp;&amp;... args);
</code></pre>
<p>减少一次内存申请, 一次性申请 <code>T</code> 和 <code>count</code> 的内存空间</p>
<p> </p>
<h4 id="4-3-所有权转移">4.3 所有权转移</h4>
<pre><code class="language-c++">shared_ptr&lt;widget&gt; factory();               // source + shared ownership 
void share( shared_ptr&lt;widget&gt; );           // share: &quot;will&quot; retain refcount
void reseat( shared_ptr&lt;widget&gt;&amp; );         // &quot;will&quot; or &quot;might&quot; reseat ptr
void may_share( const shared_ptr&lt;widget&gt;&amp; );// &quot;might&quot; retain refcount
</code></pre>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 Vanadium的小屋
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Vanadium
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>

    <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
    <script>
        var now = new Date(); 
        function createtime() { 
            var grt= new Date("09/26/2023 17:38:00");//在此处修改你的建站时间，格式：月/日/年 时:分:秒
            now.setTime(now.getTime()+250); 
            days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
            hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
            if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
            mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
            seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
            snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
            document.getElementById("timeDate").innerHTML = "本站已经存活 "+dnum+" 天 "; 
            document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
        } 
    setInterval("createtime()",250);
    </script>

</footer>
        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
</body>
</html>
